/* MIT Licensed */
!async function(t,e){"use strict";var n,a,o,s,r,i,c,u,l,d,p,h,m,y,g,f,b,S,P,_,A,C,I,v;e.exports&&e.exports!==globalThis&&Object.defineProperty(e.exports,"__esModule",{value:!0});var x,k,B,O,w,T=t.Blackprint.loadScope({url:import.meta.url,hasInterface:!0});let H=t.crypto;if(t.Blackprint.Environment.isNode)H=(await import("crypto")).webcrypto,await import("../node_modules/@polkadot/util/bundle-polkadot-util.js"),await import("../node_modules/@polkadot/util-crypto/bundle-polkadot-util-crypto.js"),await import("../node_modules/@polkadot/keyring/bundle-polkadot-keyring.js"),await import("../node_modules/@polkadot/types/bundle-polkadot-types.js"),await import("../node_modules/@polkadot/api/bundle-polkadot-api.js"),({polkadotApi:x,polkadotKeyring:k,polkadotTypes:B,polkadotUtilCrypto:O,polkadotUtil:w}=t);else{let e=["https://cdn.jsdelivr.net/npm/@polkadot/util@8.3.3/bundle-polkadot-util.min.js","https://cdn.jsdelivr.net/npm/@polkadot/util-crypto@8.3.3/bundle-polkadot-util-crypto.min.js","https://cdn.jsdelivr.net/npm/@polkadot/keyring@8.3.3/bundle-polkadot-keyring.min.js","https://cdn.jsdelivr.net/npm/@polkadot/types@7.7.1/bundle-polkadot-types.min.js","https://cdn.jsdelivr.net/npm/@polkadot/api@7.7.1/bundle-polkadot-api.min.js"];if(t.Blackprint.Environment.isDeno)for(var V=0;V<e.length;V++)await import(e[V]);else e.push("https://cdn.jsdelivr.net/npm/@polkadot/extension-dapp@0.42.7/bundle-polkadot-extension-dapp.js"),await sf.loader.js(e,{ordered:!0});({polkadotApi:x,polkadotKeyring:k,polkadotTypes:B,polkadotUtilCrypto:O,polkadotUtil:w}=t)}var E=T.createContext("Polkadot.js");E.EventSlot={slot:"my-private-event-slot"};var M=new x.Keyring({type:"ed25519",ss58Format:0});class R{constructor(t){this.txn=t}}class D{constructor(t,e,n){this.isPair=t,this.address=e,this.signer=n}}T.utils.renameTypeName({Transaction:R,Signer:D,ApiPromise:x.ApiPromise,Keyring:x.Keyring,WsProvider:x.WsProvider,HttpProvider:x.HttpProvider});let K,N=E.NodeToast=class{constructor(t){this.iface=t}clear(){this.haveInfo&&this.haveInfo.destroy(),this.haveWarn&&this.haveWarn.destroy(),this.haveError&&this.haveError.destroy(),this.haveInfo=!1,this.haveWarn=!1,this.haveError=!1}_reduceText(t){return t.replace(/\w{15,}/g,(t=>t.slice(0,5)+"..."))}info(t){if(!this.iface.$decoration)return;let e=t;t=this._reduceText(t),this.haveInfo?this.haveInfo.text=t:this.haveInfo=this.iface.$decoration.info(t),this.haveInfo._raw=e}warn(t){if(!this.iface.$decoration)return;let e=t;t=this._reduceText(t),this.haveWarn?this.haveWarn.text=t:this.haveWarn=this.iface.$decoration.warn(t),this.haveWarn._raw=e}error(t){if(!this.iface.$decoration)return;let e=t;t=this._reduceText(t),this.haveError?this.haveError.text=t:this.haveError=this.iface.$decoration.error(t),this.haveError._raw=e}success(t){if(!this.iface.$decoration)return;this.iface.$decoration.success(this._reduceText(t))._raw=t}},U={SubmitAndWatchExtrinsic:"author",Subscribe:"eth",SubscribeAllHeads:"chain",SubscribeFinalizedHeads:"chain",SubscribeJustifications:"grandpa",SubscribeNewHeads:"chain",SubscribeRuntimeVersion:"state",SubscribeStorage:"state"},F={AccountId:String,ApplyExtrinsicResult:null,BeefySignedCommitment:null,BlockHash:null,BlockNumber:Number,Bytes:String,ChainProperties:null,ChainType:null,ContractCallRequest:null,ContractExecResult:null,ContractInstantiateResult:null,CreatedBlock:null,EthAccount:null,EthCallRequest:null,EthFilter:null,EthFilterChanges:null,EthReceipt:null,EthRichBlock:null,EthSubKind:null,EthSubParams:null,EthSyncStatus:null,EthTransaction:null,EthTransactionRequest:null,EthWork:null,Extrinsic:null,ExtrinsicStatus:null,FeeDetails:null,H64:String,H160:String,H256:String,Hash:String,"HashMap<AuthorityId,EpochAuthorship>":null,Header:null,Health:null,Index:null,InstantiateRequest:null,Json:null,Justification:null,JustificationNotification:null,Metadata:null,MmrLeafProof:null,NetworkState:null,Null:null,"Option<BlockNumber>":null,"Option<Bytes>":null,"Option<EncodedFinalityProofs>":null,"Option<EthRichBlock>":null,"Option<Hash>":null,"Option<StorageData>":null,"Option<Text>":null,"Option<u64>":null,PrefixedStorageKey:null,ReadProof:null,ReportedRoundStates:null,RpcMethods:null,RuntimeDispatchInfo:null,RuntimeVersion:null,SignedBlock:null,StorageChangeSet:null,StorageData:null,StorageKey:null,StorageKind:null,String:null,SyncState:null,Text:String,TraceBlockResponse:null,U64:Number,U256:Number,"Vec<EthLog>":null,"Vec<Extrinsic>":null,"Vec<ExtrinsicOrHash>":null,"Vec<H160>":null,"Vec<H256>":null,"Vec<Hash>":null,"Vec<KeyValue>":null,"Vec<NodeRole>":null,"Vec<Option<StorageData>>":null,"Vec<PeerInfo>":null,"Vec<StorageChangeSet>":null,"Vec<StorageKey>":null,"Vec<Text>":null,bool:Boolean,u32:Number,u64:Number};function q(t,e){let n=t.trim().replace(/\t+| /g,"").split("\n");for(var a=0;a<n.length;a++){let t,s,r,i=n[a];!1===e.returnType&&(i+=":Any"),e.isConst&&(i=i.replace(":","():")),[i,r]=i.split("):"),[t,s]=i.split("("),void 0===s&&console.error(`Incorrect format "${i}", `);let c=[];if(e.typeAsName)try{c=s.split(","),s=c.join(";;")}catch(t){console.error(`Incorrect format "${i}", `,t)}else s=s.replace(/,?([a-zA-Z0-9_?]+):/g,(function(t,e){return c.push(e),";;"})).replace(/^;;/m,"");let u={};if(""!==s){s=s.split(";;");for(var o=0;o<s.length;o++){let t=c[o];t=t.slice(0,1).toUpperCase()+t.slice(1),u[t]=s[o]}}n[a]={name:t.slice(0,1).toUpperCase()+t.slice(1),args:u,returnType:r}}return n}function j(t,e){let{namespace:n,description:a,apiPath:o,isConst:s}=t;for(var r=0;r<e.length;r++){let c=e[r],u=q(c.funcs,t);t:for(var i=0;i<u.length;i++){let e=u[i];if(/subscribe|watch/i.test(e.name)&&!t.loose){void 0===U[e.name]&&console.error(`Substrate subscriber for "${e.name}" was not found`);continue}if(void 0===F[e.returnType]&&!t.loose){console.error(`Substrate type data for "${e.returnType}" was not found`);continue}let r=e.returnType,l=null;if("Null"!==e.returnType){let n=e.returnType.replace(/(Vec|Option|HashMap)<(.*?)>$/m,(function(t,e,n){return n}));t.loose&&void 0===F[e.returnType]&&(F[e.returnType]=null),l=F[e.returnType],e.returnType={[n]:F[e.returnType]},r=n}else e.returnType=void 0;let d=e.args,p=Object.keys(d);for(let e in d){let n=d[e];if(t.loose&&void 0===F[n]&&(F[n]=null),void 0===F[n]){console.error(`Substrate type data for "${n}" was not found`);continue t}d[e]=F[n]}let h=e.name.replace(/By([A-Z].*)/,(function(t,e){return" By/"+e})).replace(/^(Get|Set|Has|New)([A-Z].*)/,(function(t,e,n){return e+"/"+n})).replace(/([a-z])([A-Z])/g,(function(t,e,n){return e+" "+n})),m=e.name.slice(0,1).toLowerCase()+e.name.slice(1),y={API:x.ApiPromise,Trigger:T.Port.Trigger((function(){this.trigger()}))};s&&delete y.Trigger;class g extends T.Node{constructor(t){super(t);let n=this.setInterface();n.title=`${c.name} ${e.name}`,n.description=a,this._toast=new N(n)}update(){let{Input:t,Output:e}=this.ref;if(this._toast.clear(),null!=t.API){if(null==t.API[o][c.rpc_path][m])return void this._toast.error("This network doesn't support this feature")}else e[r]=null;s&&this.trigger()}async trigger(){let{Input:t,Output:e}=this.ref,n=this._toast;if(null===t.API)return n.warn("API is required");let a=t.API[o][c.rpc_path],i=[];for(var u=0;u<p.length;u++)i.push(t[p[u]]);try{var d=s?a[m]:await a[m].apply(a,i)}catch(t){return e[r]=null,void n.error(t.message)}null!=l&&(d=l(d)),e[r]=d}}g.output=e.returnType,g.input=Object.assign(y,d),T.registerNode(`Polkadot.js/${n}/${c.name}/${h}`,g)}}}j({namespace:"RPC",description:"[Experimental] Substrate JSON-RPC",apiPath:"rpc"},[{name:"Author",rpc_path:"author",funcs:"\n\t\t\thasKey(publicKey: Bytes, keyType: Text): bool\n\t\t\thasSessionKeys(sessionKeys: Bytes): bool\n\t\t\tinsertKey(keyType: Text, suri: Text, publicKey: Bytes): Bytes\n\t\t\tpendingExtrinsics(): Vec<Extrinsic>\n\t\t\tremoveExtrinsic(bytesOrHash: Vec<ExtrinsicOrHash>): Vec<Hash>\n\t\t\trotateKeys(): Bytes\n\t\t\tsubmitAndWatchExtrinsic(extrinsic: Extrinsic): ExtrinsicStatus\n\t\t\tsubmitExtrinsic(extrinsic: Extrinsic): Hash\n\t\t"},{name:"Babe",rpc_path:"babe",funcs:"\n\t\t\tepochAuthorship(): HashMap<AuthorityId, EpochAuthorship>\n\t\t"},{name:"Beefy",rpc_path:"beefy",funcs:"\n\t\t\tsubscribeJustifications(): BeefySignedCommitment\n\t\t"},{name:"Chain",rpc_path:"chain",funcs:"\n\t\t\tgetBlock(hash?: BlockHash): SignedBlock\n\t\t\tgetBlockHash(blockNumber?: BlockNumber): BlockHash\n\t\t\tgetFinalizedHead(): BlockHash\n\t\t\tgetHeader(hash?: BlockHash): Header\n\t\t\tsubscribeAllHeads(): Header\n\t\t\tsubscribeFinalizedHeads(): Header\n\t\t\tsubscribeNewHeads(): Header\n\t\t"},{name:"ChildState",rpc_path:"childstate",funcs:"\n\t\t\tgetKeys(childKey: PrefixedStorageKey, prefix: StorageKey, at?: Hash): Vec<StorageKey>\n\t\t\tgetKeysPaged(childKey: PrefixedStorageKey, prefix: StorageKey, count: u32, startKey?: StorageKey, at?: Hash): Vec<StorageKey>\n\t\t\tgetStorage(childKey: PrefixedStorageKey, key: StorageKey, at?: Hash): Option<StorageData>\n\t\t\tgetStorageEntries(childKey: PrefixedStorageKey, keys: Vec<StorageKey>, at?: Hash): Vec<Option<StorageData>>\n\t\t\tgetStorageHash(childKey: PrefixedStorageKey, key: StorageKey, at?: Hash): Option<Hash>\n\t\t\tgetStorageSize(childKey: PrefixedStorageKey, key: StorageKey, at?: Hash): Option<u64>\n\t\t"},{name:"Contracts",rpc_path:"contracts",funcs:"\n\t\t\tcall(callRequest: ContractCallRequest, at?: BlockHash): ContractExecResult\n\t\t\tgetStorage(address: AccountId, key: H256, at?: BlockHash): Option<Bytes>\n\t\t\tinstantiate(request: InstantiateRequest, at?: BlockHash): ContractInstantiateResult\n\t\t\trentProjection(address: AccountId, at?: BlockHash): Option<BlockNumber>\n\t\t"},{name:"Engine",rpc_path:"engine",funcs:"\n\t\t\tcreateBlock(createEmpty: bool, finalize: bool, parentHash?: BlockHash): CreatedBlock\n\t\t\tfinalizeBlock(hash: BlockHash, justification?: Justification): bool\n\t\t"},{name:"Eth",rpc_path:"eth",funcs:"\n\t\t\taccounts(): Vec<H160>\n\t\t\tblockNumber(): U256\n\t\t\tcall(request: EthCallRequest, number?: BlockNumber): Bytes\n\t\t\tchainId(): U64\n\t\t\tcoinbase(): H160\n\t\t\testimateGas(request: EthCallRequest, number?: BlockNumber): U256\n\t\t\tgasPrice(): U256\n\t\t\tgetBalance(address: H160, number?: BlockNumber): U256\n\t\t\tgetBlockByHash(hash: H256, full: bool): Option<EthRichBlock>\n\t\t\tgetBlockByNumber(block: BlockNumber, full: bool): Option<EthRichBlock>\n\t\t\tgetBlockTransactionCountByHash(hash: H256): U256\n\t\t\tgetBlockTransactionCountByNumber(block: BlockNumber): U256\n\t\t\tgetCode(address: H160, number?: BlockNumber): Bytes\n\t\t\tgetFilterChanges(index: U256): EthFilterChanges\n\t\t\tgetFilterLogs(index: U256): Vec<EthLog>\n\t\t\tgetLogs(filter: EthFilter): Vec<EthLog>\n\t\t\tgetProof(address: H160, storageKeys: Vec<H256>, number: BlockNumber): EthAccount\n\t\t\tgetStorageAt(address: H160, index: U256, number?: BlockNumber): H256\n\t\t\tgetTransactionByBlockHashAndIndex(hash: H256, index: U256): EthTransaction\n\t\t\tgetTransactionByBlockNumberAndIndex(number: BlockNumber, index: U256): EthTransaction\n\t\t\tgetTransactionByHash(hash: H256): EthTransaction\n\t\t\tgetTransactionCount(hash: H256, number?: BlockNumber): U256\n\t\t\tgetTransactionReceipt(hash: H256): EthReceipt\n\t\t\tgetUncleByBlockHashAndIndex(hash: H256, index: U256): EthRichBlock\n\t\t\tgetUncleByBlockNumberAndIndex(number: BlockNumber, index: U256): EthRichBlock\n\t\t\tgetUncleCountByBlockHash(hash: H256): U256\n\t\t\tgetUncleCountByBlockNumber(number: BlockNumber): U256\n\t\t\tgetWork(): EthWork\n\t\t\thashrate(): U256\n\t\t\tmining(): bool\n\t\t\tnewBlockFilter(): U256\n\t\t\tnewFilter(filter: EthFilter): U256\n\t\t\tnewPendingTransactionFilter(): U256\n\t\t\tprotocolVersion(): u64\n\t\t\tsendRawTransaction(bytes: Bytes): H256\n\t\t\tsendTransaction(tx: EthTransactionRequest): H256\n\t\t\tsubmitHashrate(index: U256, hash: H256): bool\n\t\t\tsubmitWork(nonce: H64, headerHash: H256, mixDigest: H256): bool\n\t\t\tsubscribe(kind: EthSubKind, params?: EthSubParams): Null\n\t\t\tsyncing(): EthSyncStatus\n\t\t\tuninstallFilter(index: U256): bool\n\t\t"},{name:"Eth/Net",rpc_path:"net",funcs:"\n\t\t\tlistening(): bool\n\t\t\tpeerCount(): String\n\t\t\tversion(): String\n\t\t"},{name:"Eth/Web3",rpc_path:"web3",funcs:"\n\t\t\tclientVersion(): String\n\t\t\tsha3(data: Bytes): H256\n\t\t"},{name:"Grandpa",rpc_path:"grandpa",funcs:"\n\t\t\tproveFinality(begin: BlockHash, end: BlockHash, authoritiesSetId?: u64): Option<EncodedFinalityProofs>\n\t\t\troundState(): ReportedRoundStates\n\t\t\tsubscribeJustifications(): JustificationNotification\n\t\t"},{name:"Mmr",rpc_path:"mmr",funcs:"\n\t\t\tgenerateProof(leafIndex: u64, at?: BlockHash): MmrLeafProof\n\t\t"},{name:"OffChain",rpc_path:"offchain",funcs:"\n\t\t\tlocalStorageGet(kind: StorageKind, key: Bytes): Option<Bytes>\n\t\t\tlocalStorageSet(kind: StorageKind, key: Bytes, value: Bytes): Null\n\t\t"},{name:"Payment",rpc_path:"payment",funcs:"\n\t\t\tqueryFeeDetails(extrinsic: Bytes, at?: BlockHash): FeeDetails\n\t\t\tqueryInfo(extrinsic: Bytes, at?: BlockHash): RuntimeDispatchInfo\n\t\t"},{name:"RPC",rpc_path:"rpc",funcs:"\n\t\t\tmethods(): RpcMethods\n\t\t"},{name:"State",rpc_path:"state",funcs:"\n\t\t\tcall(method: Text, data: Bytes, at?: BlockHash): Bytes\n\t\t\tgetChildKeys(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): Vec<StorageKey>\n\t\t\tgetChildReadProof(childStorageKey: PrefixedStorageKey, keys: Vec<StorageKey>, at?: BlockHash): ReadProof\n\t\t\tgetChildStorage(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): StorageData\n\t\t\tgetChildStorageHash(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): Hash\n\t\t\tgetChildStorageSize(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): u64\n\t\t\tgetKeys(key: StorageKey, at?: BlockHash): Vec<StorageKey>\n\t\t\tgetKeysPaged(key: StorageKey, count: u32, startKey?: StorageKey, at?: BlockHash): Vec<StorageKey>\n\t\t\tgetMetadata(at?: BlockHash): Metadata\n\t\t\tgetPairs(prefix: StorageKey, at?: BlockHash): Vec<KeyValue>\n\t\t\tgetReadProof(keys: Vec<StorageKey>, at?: BlockHash): ReadProof\n\t\t\tgetRuntimeVersion(at?: BlockHash): RuntimeVersion\n\t\t\tgetStorage(key: StorageKey, at?: BlockHash): StorageData\n\t\t\tgetStorageHash(key: StorageKey, at?: BlockHash): Hash\n\t\t\tgetStorageSize(key: StorageKey, at?: BlockHash): u64\n\t\t\tqueryStorage(keys: Vec<StorageKey>, fromBlock: Hash, toBlock?: BlockHash): Vec<StorageChangeSet>\n\t\t\tqueryStorageAt(keys: Vec<StorageKey>, at?: BlockHash): Vec<StorageChangeSet>\n\t\t\tsubscribeRuntimeVersion(): RuntimeVersion\n\t\t\tsubscribeStorage(keys?: Vec<StorageKey>): StorageChangeSet\n\t\t\ttraceBlock(block: Hash, targets: Option<Text>, storageKeys: Option<Text>, methods: Option<Text>): TraceBlockResponse\n\t\t"},{name:"SyncState",rpc_path:"syncstate",funcs:"\n\t\t\tgenSyncSpec(raw: bool): Json\n\t\t"},{name:"System",rpc_path:"system",funcs:"\n\t\t\taccountNextIndex(accountId: AccountId): Index\n\t\t\taddLogFilter(directives: Text): Null\n\t\t\taddReservedPeer(peer: Text): Text\n\t\t\tchain(): Text\n\t\t\tchainType(): ChainType\n\t\t\tdryRun(extrinsic: Bytes, at?: BlockHash): ApplyExtrinsicResult\n\t\t\thealth(): Health\n\t\t\tlocalListenAddresses(): Vec<Text>\n\t\t\tlocalPeerId(): Text\n\t\t\tname(): Text\n\t\t\tnetworkState(): NetworkState\n\t\t\tnodeRoles(): Vec<NodeRole>\n\t\t\tpeers(): Vec<PeerInfo>\n\t\t\tproperties(): ChainProperties\n\t\t\tremoveReservedPeer(peerId: Text): Text\n\t\t\treservedPeers(): Vec<Text>\n\t\t\tresetLogFilter(): Null\n\t\t\tsyncState(): SyncState\n\t\t\tversion(): Text\n\t\t"}]),T.registerNode("Polkadot.js/Account/Transfer",((n=class extends T.Node{constructor(t){super(t);let e=this.setInterface();e.title="Transfer",e.description="Transfer balance to an address"}imported(){let{Input:t,Output:e,IInput:n,IOutput:a}=this.ref,o=new N(this.iface);function s(){if(!t.Address)return o.warn("Address is required");if(!t.Value)return o.warn("Value is required");if(null===t.API)return o.warn("API is required");o.clear();let n=t.API.tx.balances.transfer(t.Address,+t.Value);e.Txn=new R(n)}this.iface.on("port.value",E.EventSlot,s),this.iface.on("cable.disconnect",E.EventSlot,(function({port:t}){"input"===t.source&&s()}))}}).input={API:x.ApiPromise,Address:String,Value:String},n.output={Txn:R},n));let L=new Promise((t=>K=t));class W{constructor(t){this._dAppName="BP-Polkadot.js",this._iface=t}get dAppName(){return this._dAppName}set dAppName(t){this._dAppName=t}}T.registerNode("Polkadot.js/Connection/Extension",((a=class extends T.Node{constructor(t){super(t);let e=this.setInterface("BPIC/Polkadot.js/Connection/Extension");e.title="Browser Wallet",e.description="Connect to extension"}imported(t){t&&Object.assign(this.iface.data,t)}}).input=void 0,a.output={Accounts:Array,IsAllowed:Boolean},a)),T.registerInterface("BPIC/Polkadot.js/Connection/Extension",E.IFace.ConnectionExtension=class extends T.Interface{constructor(t){super(t),this._toast=new N(this),this._toast.warn("Disconnected"),this.data=new W(this)}async init(){let{Input:e,Output:n,IInput:a,IOutput:o}=this.ref,s=t.injectedWeb3?.["polkadot-js"];if(void 0===s)return this._toast.error("Extension injection was not found");this._toast.clear(),this._toast.warn("Asking for Permission");try{this._polkadot=await polkadotExtensionDapp.web3Enable(this.data.dAppName)}catch(t){return n.IsAllowed=!1,this._toast.clear(),void this._toast.warn("Access Rejected")}this._toast.clear(),this._toast.success("Access Granted"),n.IsAllowed=!0,K(),L=!0,this.node.output.Accounts=await polkadotExtensionDapp.web3Accounts();this._unsubscribe=await polkadotExtensionDapp.web3AccountsSubscribe((t=>{this.node.output.Accounts=t}))}destroy(){try{this._unsubscribe?.()}catch(t){console.error(t)}}async _connect(){let{Input:t,Output:e,IInput:n,IOutput:a}=this.ref;this._polkadot;this._toast.clear()}});class z{constructor(t){this._rpcURL="",this._iface=t}get rpcURL(){return this._rpcURL}set rpcURL(t){this._rpcURL=t,this._iface.changeRPC()}}T.registerNode("Polkadot.js/Connection/HTTP",((o=class extends T.Node{constructor(t){super(t);let e=this.setInterface("BPIC/Polkadot.js/Connection/HTTP");e.title="HTTP",e.description="Web3 RPC Connection",e.data=new z(e)}imported(t){t&&Object.assign(this.iface.data,t)}destroy(){let t=this.ref.Output.Provider;void 0!==t&&(t.disconnect(),this.ref.Output.Disconnected())}}).input={Reconnect:T.Port.Trigger((function(){this.iface.changeRPC()}))},o.output={Provider:x.HttpProvider,API:x.ApiPromise,Connected:Function,Disconnected:Function},o)),T.registerInterface("BPIC/Polkadot.js/Connection/HTTP",E.IFace.ConnectionHTTP=class extends T.Interface{constructor(t){super(t),this._toast=new N(this),this._toast.warn("Disconnected")}async changeRPC(){let{Input:t,Output:e}=this.ref;this._toast.clear();let n=this.data.rpcURL;if(!n)return this._toast.error("RPC URL was empty");if(!/^(https|http):\/\//.test(n))return this._toast.error("The endpoint should start with http:// or https://");null!=e.Provider&&(e.Provider.disconnect(),e.Disconnected());let a=e.Provider=new x.HttpProvider(n);this._toast.warn("Connecting...");try{var o=await x.ApiPromise.create({provider:a,throwOnConnect:!0})}catch(t){return this._toast.warn("Connection failed"),e.API=null,void e.Disconnected()}e.API=o,a.isConnected?(this._toast.clear(),this._toast.success("Connected"),e.Connected()):(this._toast.error("Failed to connect"),e.Disconnected())}});class G{constructor(t){this._rpcURL="",this._iface=t}get rpcURL(){return this._rpcURL}set rpcURL(t){this._rpcURL=t,this._iface.changeRPC()}}T.registerNode("Polkadot.js/Connection/WebSocket",((s=class extends T.Node{constructor(t){super(t);let e=this.setInterface("BPIC/Polkadot.js/Connection/WebSocket");e.title="WebSocket",e.description="Web3 RPC Connection",e.data=new G(e)}imported(t){t&&Object.assign(this.iface.data,t)}destroy(){let t=this.ref.Output.Provider;void 0!==t&&t.disconnect()}}).input={Connect:T.Port.Trigger((function(){this.output.Provider?.connect()})),Disconnect:T.Port.Trigger((function(){this.output.Provider?.disconnect()}))},s.output={Provider:x.WsProvider,API:x.ApiPromise,Connected:Function,Disconnected:Function},s)),T.registerInterface("BPIC/Polkadot.js/Connection/WebSocket",E.IFace.ConnectionWebSocket=class extends T.Interface{constructor(t){super(t),this._toast=new N(this),this._toast.warn("Disconnected")}async changeRPC(){let{Input:t,Output:e}=this.ref;this._toast.clear(),e.Provider?.disconnect();let n=this.data.rpcURL;if(!n)return this._toast.error("RPC URL was empty");if(!/^(wss|ws):\/\//.test(n))return this._toast.error("The endpoint should start with ws:// or wss://");let a=e.Provider=new x.WsProvider(n);a.on("connected",(()=>{this._toast.clear(),this._toast.success("Connected"),e.Connected()})),a.on("disconnected",(()=>{this._toast.warn("Disconnected"),e.Disconnected()})),this._toast.warn("Connecting..."),e.API=await x.ApiPromise.create({provider:a})}}),j({namespace:"Constants",description:"[Experimental] Substrate Constants",apiPath:"consts",loose:!0,isConst:!0},[{name:"Assets",rpc_path:"assets",funcs:"\n\t\t\tapprovalDeposit: u128\n\t\t\tassetAccountDeposit: u128\n\t\t\tassetDeposit: u128\n\t\t\tmetadataDepositBase: u128\n\t\t\tmetadataDepositPerByte: u128\n\t\t\tstringLimit: u32\n\t\t"},{name:"Authorship",rpc_path:"authorship",funcs:"\n\t\t\tuncleGenerations: u32\n\t\t"},{name:"Babe",rpc_path:"babe",funcs:"\n\t\t\tepochDuration: u64\n\t\t\texpectedBlockTime: u64\n\t\t\tmaxAuthorities: u32\n\t\t"},{name:"BagsList",rpc_path:"bagsList",funcs:"\n\t\t\tbagThresholds: Vec<u64>\n\t\t"},{name:"Balances",rpc_path:"balances",funcs:"\n\t\t\texistentialDeposit: u128\n\t\t\tmaxLocks: u32\n\t\t\tmaxReserves: u32\n\t\t"},{name:"Bounties",rpc_path:"bounties",funcs:"\n\t\t\tbountyCuratorDeposit: Permill\n\t\t\tbountyDepositBase: u128\n\t\t\tbountyDepositPayoutDelay: u32\n\t\t\tbountyUpdatePeriod: u32\n\t\t\tbountyValueMinimum: u128\n\t\t\tdataDepositPerByte: u128\n\t\t\tmaximumReasonLength: u32\n\t\t"},{name:"ChildBounties",rpc_path:"childBounties",funcs:"\n\t\t\tchildBountyCuratorDepositBase: Permill\n\t\t\tchildBountyValueMinimum: u128\n\t\t\tmaxActiveChildBountyCount: u32\n\t\t"},{name:"Contracts",rpc_path:"contracts",funcs:"\n\t\t\tdeletionQueueDepth: u32\n\t\t\tdeletionWeightLimit: u64\n\t\t\tdepositPerByte: u128\n\t\t\tdepositPerItem: u128\n\t\t\tschedule: PalletContractsSchedule\n\t\t"},{name:"Democracy",rpc_path:"democracy",funcs:"\n\t\t\tcooloffPeriod: u32\n\t\t\tenactmentPeriod: u32\n\t\t\tfastTrackVotingPeriod: u32\n\t\t\tinstantAllowed: bool\n\t\t\tlaunchPeriod: u32\n\t\t\tmaxProposals: u32\n\t\t\tmaxVotes: u32\n\t\t\tminimumDeposit: u128\n\t\t\tpreimageByteDeposit: u128\n\t\t\tvoteLockingPeriod: u32\n\t\t\tvotingPeriod: u32\n\t\t"},{name:"ElectionProviderMultiPhase",rpc_path:"electionProviderMultiPhase",funcs:"\n\t\t\tminerMaxLength: u32\n\t\t\tminerMaxWeight: u64\n\t\t\tminerTxPriority: u64\n\t\t\toffchainRepeat: u32\n\t\t\tsignedDepositBase: u128\n\t\t\tsignedDepositByte: u128\n\t\t\tsignedDepositWeight: u128\n\t\t\tsignedMaxSubmissions: u32\n\t\t\tsignedMaxWeight: u64\n\t\t\tsignedPhase: u32\n\t\t\tsignedRewardBase: u128\n\t\t\tsolutionImprovementThreshold: Perbill\n\t\t\tunsignedPhase: u32\n\t\t\tvoterSnapshotPerBlock: u32\n\t\t"},{name:"Elections",rpc_path:"elections",funcs:"\n\t\t\tcandidacyBond: u128\n\t\t\tdesiredMembers: u32\n\t\t\tdesiredRunnersUp: u32\n\t\t\tpalletId: [u8;8]\n\t\t\ttermDuration: u32\n\t\t\tvotingBondBase: u128\n\t\t\tvotingBondFactor: u128\n\t\t"},{name:"Gilt",rpc_path:"gilt",funcs:"\n\t\t\tfifoQueueLen: u32\n\t\t\tintakePeriod: u32\n\t\t\tmaxIntakeBids: u32\n\t\t\tmaxQueueLen: u32\n\t\t\tminFreeze: u128\n\t\t\tperiod: u32\n\t\t\tqueueCount: u32\n\t\t"},{name:"Grandpa",rpc_path:"grandpa",funcs:"\n\t\t\tmaxAuthorities: u32\n\t\t"},{name:"Identity",rpc_path:"identity",funcs:"\n\t\t\tbasicDeposit: u128\n\t\t\tfieldDeposit: u128\n\t\t\tmaxAdditionalFields: u32\n\t\t\tmaxRegistrars: u32\n\t\t\tmaxSubAccounts: u32\n\t\t\tsubAccountDeposit: u128\n\t\t"},{name:"ImOnline",rpc_path:"imOnline",funcs:"\n\t\t\tunsignedPriority: u64\n\t\t"},{name:"Indices",rpc_path:"indices",funcs:"\n\t\t\tdeposit: u128\n\t\t"},{name:"Lottery",rpc_path:"lottery",funcs:"\n\t\t\tmaxCalls: u32\n\t\t\tmaxGenerateRandom: u32\n\t\t\tpalletId: FrameSupportPalletId\n\t\t"},{name:"Multisig",rpc_path:"multisig",funcs:"\n\t\t\tdepositBase: u128\n\t\t\tdepositFactor: u128\n\t\t\tmaxSignatories: u16\n\t\t"},{name:"Proxy",rpc_path:"proxy",funcs:"\n\t\t\tannouncementDepositBase: u128\n\t\t\tannouncementDepositFactor: u128\n\t\t\tmaxPending: u32\n\t\t\tmaxProxies: u32\n\t\t\tproxyDepositBase: u128\n\t\t\tproxyDepositFactor: u128\n\t\t"},{name:"Recovery",rpc_path:"recovery",funcs:"\n\t\t\tconfigDepositBase: u128\n\t\t\tfriendDepositFactor: u128\n\t\t\tmaxFriends: u16\n\t\t\trecoveryDeposit: u128\n\t\t"},{name:"Scheduler",rpc_path:"scheduler",funcs:"\n\t\t\tmaximumWeight: u64\n\t\t\tmaxScheduledPerBlock: u32\n\t\t"},{name:"Society",rpc_path:"society",funcs:"\n\t\t\tcandidateDeposit: u128\n\t\t\tchallengePeriod: u32\n\t\t\tmaxCandidateIntake: u32\n\t\t\tmaxLockDuration: u32\n\t\t\tmaxStrikes: u32\n\t\t\tpalletId: FrameSupportPalletId\n\t\t\tperiodSpend: u128\n\t\t\trotationPeriod: u32\n\t\t\twrongSideDeduction: u128\n\t\t"},{name:"Staking",rpc_path:"staking",funcs:"\n\t\t\tbondingDuration: u32\n\t\t\tmaxNominatorRewardedPerValidator: u32\n\t\t\tsessionsPerEra: u32\n\t\t\tslashDeferDuration: u32\n\t\t"},{name:"System",rpc_path:"system",funcs:"\n\t\t\tblockHashCount: u32\n\t\t\tblockLength: FrameSystemLimitsBlockLength\n\t\t\tblockWeights: FrameSystemLimitsBlockWeights\n\t\t\tdbWeight: FrameSupportWeightsRuntimeDbWeight\n\t\t\tss58Prefix: u16\n\t\t\tversion: SpVersionRuntimeVersion\n\t\t"},{name:"Timestamp",rpc_path:"timestamp",funcs:"\n\t\t\tminimumPeriod: u64\n\t\t"},{name:"Tips",rpc_path:"tips",funcs:"\n\t\t\tdataDepositPerByte: u128\n\t\t\tmaximumReasonLength: u32\n\t\t\ttipCountdown: u32\n\t\t\ttipFindersFee: Percent\n\t\t\ttipReportDepositBase: u128\n\t\t"},{name:"TransactionPayment",rpc_path:"transactionPayment",funcs:"\n\t\t\toperationalFeeMultiplier: u8\n\t\t\ttransactionByteFee: u128\n\t\t\tweightToFee: Vec<FrameSupportWeightsWeightToFeeCoefficient>\n\t\t"},{name:"Treasury",rpc_path:"treasury",funcs:"\n\t\t\tburn: Permill\n\t\t\tmaxApprovals: u32\n\t\t\tpalletId: FrameSupportPalletId\n\t\t\tproposalBond: Permill\n\t\t\tproposalBondMaximum: Option<u128>\n\t\t\tproposalBondMinimum: u128\n\t\t\tspendPeriod: u32\n\t\t"},{name:"Uniques",rpc_path:"uniques",funcs:"\n\t\t\tattributeDepositBase: u128\n\t\t\tclassDeposit: u128\n\t\t\tdepositPerByte: u128\n\t\t\tinstanceDeposit: u128\n\t\t\tkeyLimit: u32\n\t\t\tmetadataDepositBase: u128\n\t\t\tstringLimit: u32\n\t\t\tvalueLimit: u32\n\t\t"},{name:"Utility",rpc_path:"utility",funcs:"\n\t\t\tbatchedCallsLimit: u32\n\t\t"},{name:"Vesting",rpc_path:"vesting",funcs:"\n\t\t\tmaxVestingSchedules: u32\n\t\t\tminVestedTransfer: u128\n\t\t"}]),T.registerNode("Polkadot.js/Convert/Mnemonic",((r=class extends T.Node{constructor(t){super(t);let e=this.setInterface();e.title="Mnemonic",this._toast=new N(e)}init(){this.iface.input.Text.on("disconnect",E.EventSlot,(()=>{this.output.Seed=null}))}update(){let{Input:t,Output:e}=this.ref,{mnemonicToMiniSecret:n,mnemonicValidate:a}=O,o=this._toast;try{if(!a(t.Text))return o.warn("Invalid mnemonic");e.Seed=n(t.Text),o.clear()}catch(t){return o.warn(t.message)}}}).input={Text:String},r.output={Seed:Uint8Array},r)),T.registerNode("Polkadot.js/Data/Sign",((i=class extends T.Node{constructor(t){super(t);let e=this.setInterface();e.title="Sign",e.description="Data/transaction signer",this._toast=new N(this.iface),this.iface.on("cable.disconnect",E.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}_fail(t){this.output.Bytes=null,this._toast.warn(t)}async update(){let{Input:t,Output:e}=this.ref;if(!t.Signer)return this._fail("Signer is required");let n=t.Data;if(!n)return this._fail("Data is required");let{signer:a,address:o,isPair:s}=t.Signer;if(this._toast.clear(),s)n.constructor===String&&(n=w.stringToU8a(n)),e.Bytes=a.sign(n);else{n.constructor===Uint8Array?n=w.u8aToHex(n):"0x"!==n.slice(0,2)&&(n=w.stringToHex(n));try{var r=await a.signRaw({type:"bytes",data:n,address:o})}catch(t){throw this._fail(t.message),t}e.Bytes=w.hexToU8a(r.signature)}}}).input={Signer:D,Data:T.Port.Union([String,Uint8Array])},i.output={Bytes:Uint8Array},i)),T.registerNode("Polkadot.js/Data/Verify",((c=class extends T.Node{constructor(t){super(t);let e=this.setInterface();e.title="Verify",e.description="Verify signed message",this._toast=new N(this.iface),this.iface.on("cable.disconnect",E.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}_fail(t){this.output.IsValid=null,this._toast.warn(t)}update(){let{Input:t,Output:e}=this.ref;if(!t.Data)return this._fail("Data is required");if(!t.Address)return this._fail("Address is required");if(!t.Signature)return this._fail("Signature is required");let n=t.Data;n.constructor===String&&(n="0x"===n.slice(0,2)?w.hexToU8a(n):w.stringToU8a(n));let a=t.Signature;if(a.constructor===String){if("0x"!==a.slice(0,2))return this._fail("Signature must be Hex or Uint8Array");a=w.hexToU8a(a)}this._toast.clear();try{var o=O.signatureVerify(n,a,t.Address)}catch(t){throw this._fail(t.message),t}e.IsValid=o.isValid}}).input={Address:String,Signature:T.Port.Union([String,Uint8Array]),Data:T.Port.Union([String,Uint8Array])},c.output={IsValid:Boolean},c)),T.registerNode("Polkadot.js/Events/Blocks",((u=class extends T.Node{constructor(t){super(t);let e=this.setInterface("BPIC/Polkadot.js/Events/Blocks");e.title="Blocks Event",e.description="Listen for new blocks",this._toast=new N(e)}init(){let{IInput:t}=this.ref;t.API.on("disconnect",E.EventSlot,(()=>{this.iface.unsubscribe()}))}destroy(){this.iface.unsubscribe()}async update(){let{Input:t,Output:e}=this.ref;this.iface.unsubscribe();let n=t.API;if(n){if(!n.hasSubscriptions)return this._toast.error("Please use WebSocket for using this feature");this._toast.clear(),this._toast.warn("Subscribing..."),this.iface.unsubscribe=await n.rpc.chain.subscribeNewHeads((t=>{e.Data=t,e.Number=this.iface.number=t.number.toNumber()})),this._toast.clear(),this._toast.success("Subscribed!")}}}).type="event",u.input={API:x.ApiPromise},u.output={Data:Object,Number:Number},u)),T.registerInterface("BPIC/Polkadot.js/Events/Blocks",E.IFace.EventsBlocks=class extends T.Interface{constructor(t){super(t),this.number=0,this.unsubscribe=()=>{}}}),j({namespace:"Extrinsics",description:"[Experimental] Substrate Extrinsics",apiPath:"tx",loose:!0,returnType:!1},[{name:"Assets",rpc_path:"assets",funcs:"\n\t\t\tapproveTransfer(id: Compact<u32>, delegate: MultiAddress, amount: Compact<u128>)\n\t\t\tburn(id: Compact<u32>, who: MultiAddress, amount: Compact<u128>)\n\t\t\tcancelApproval(id: Compact<u32>, delegate: MultiAddress)\n\t\t\tclearMetadata(id: Compact<u32>)\n\t\t\tcreate(id: Compact<u32>, admin: MultiAddress, min_balance: u128)\n\t\t\tdestroy(id: Compact<u32>, witness: PalletAssetsDestroyWitness)\n\t\t\tforceAssetStatus(id: Compact<u32>, owner: MultiAddress, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress, min_balance: Compact<u128>, is_sufficient: bool, is_frozen: bool)\n\t\t\tforceCancelApproval(id: Compact<u32>, owner: MultiAddress, delegate: MultiAddress)\n\t\t\tforceClearMetadata(id: Compact<u32>)\n\t\t\tforceCreate(id: Compact<u32>, owner: MultiAddress, is_sufficient: bool, min_balance: Compact<u128>)\n\t\t\tforceSetMetadata(id: Compact<u32>, name: Bytes, symbol: Bytes, decimals: u8, is_frozen: bool)\n\t\t\tforceTransfer(id: Compact<u32>, source: MultiAddress, dest: MultiAddress, amount: Compact<u128>)\n\t\t\tfreeze(id: Compact<u32>, who: MultiAddress)\n\t\t\tfreezeAsset(id: Compact<u32>)\n\t\t\tmint(id: Compact<u32>, beneficiary: MultiAddress, amount: Compact<u128>)\n\t\t\trefund(id: Compact<u32>, allow_burn: bool)\n\t\t\tsetMetadata(id: Compact<u32>, name: Bytes, symbol: Bytes, decimals: u8)\n\t\t\tsetTeam(id: Compact<u32>, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress)\n\t\t\tthaw(id: Compact<u32>, who: MultiAddress)\n\t\t\tthawAsset(id: Compact<u32>)\n\t\t\ttouch(id: Compact<u32>)\n\t\t\ttransfer(id: Compact<u32>, target: MultiAddress, amount: Compact<u128>)\n\t\t\ttransferApproved(id: Compact<u32>, owner: MultiAddress, destination: MultiAddress, amount: Compact<u128>)\n\t\t\ttransferKeepAlive(id: Compact<u32>, target: MultiAddress, amount: Compact<u128>)\n\t\t\ttransferOwnership(id: Compact<u32>, owner: MultiAddress)\n\t\t"},{name:"Authorship",rpc_path:"authorship",funcs:"\n\t\t\tsetUncles(new_uncles: Vec<SpRuntimeHeader>)\n\t\t"},{name:"Babe",rpc_path:"babe",funcs:"\n\t\t\tplanConfigChange(config: SpConsensusBabeDigestsNextConfigDescriptor)\n\t\t\treportEquivocation(equivocation_proof: SpConsensusSlotsEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t\treportEquivocationUnsigned(equivocation_proof: SpConsensusSlotsEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t"},{name:"BagsList",rpc_path:"bagsList",funcs:"\n\t\t\tputInFrontOf(lighter: AccountId32)\n\t\t\trebag(dislocated: AccountId32)\n\t\t"},{name:"Balances",rpc_path:"balances",funcs:"\n\t\t\tforceTransfer(source: MultiAddress, dest: MultiAddress, value: Compact<u128>)\n\t\t\tforceUnreserve(who: MultiAddress, amount: u128)\n\t\t\tsetBalance(who: MultiAddress, new_free: Compact<u128>, new_reserved: Compact<u128>)\n\t\t\ttransfer(dest: MultiAddress, value: Compact<u128>)\n\t\t\ttransferAll(dest: MultiAddress, keep_alive: bool)\n\t\t\ttransferKeepAlive(dest: MultiAddress, value: Compact<u128>)\n\t\t"},{name:"Bounties",rpc_path:"bounties",funcs:"\n\t\t\tacceptCurator(bounty_id: Compact<u32>)\n\t\t\tapproveBounty(bounty_id: Compact<u32>)\n\t\t\tawardBounty(bounty_id: Compact<u32>, beneficiary: MultiAddress)\n\t\t\tclaimBounty(bounty_id: Compact<u32>)\n\t\t\tcloseBounty(bounty_id: Compact<u32>)\n\t\t\textendBountyExpiry(bounty_id: Compact<u32>, remark: Bytes)\n\t\t\tproposeBounty(value: Compact<u128>, description: Bytes)\n\t\t\tproposeCurator(bounty_id: Compact<u32>, curator: MultiAddress, fee: Compact<u128>)\n\t\t\tunassignCurator(bounty_id: Compact<u32>)\n\t\t"},{name:"ChildBounties",rpc_path:"childBounties",funcs:"\n\t\t\tacceptCurator(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t\taddChildBounty(parent_bounty_id: Compact<u32>, value: Compact<u128>, description: Bytes)\n\t\t\tawardChildBounty(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>, beneficiary: MultiAddress)\n\t\t\tclaimChildBounty(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t\tcloseChildBounty(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t\tproposeCurator(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>, curator: MultiAddress, fee: Compact<u128>)\n\t\t\tunassignCurator(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t"},{name:"Contracts",rpc_path:"contracts",funcs:"\n\t\t\tcall(dest: MultiAddress, value: Compact<u128>, gas_limit: Compact<u64>, storage_deposit_limit: Option<Compact<u128>>, data: Bytes)\n\t\t\tinstantiate(value: Compact<u128>, gas_limit: Compact<u64>, storage_deposit_limit: Option<Compact<u128>>, code_hash: H256, data: Bytes, salt: Bytes)\n\t\t\tinstantiateWithCode(value: Compact<u128>, gas_limit: Compact<u64>, storage_deposit_limit: Option<Compact<u128>>, code: Bytes, data: Bytes, salt: Bytes)\n\t\t\tremoveCode(code_hash: H256)\n\t\t\tuploadCode(code: Bytes, storage_deposit_limit: Option<Compact<u128>>)\n\t\t"},{name:"Council",rpc_path:"council",funcs:"\n\t\t\tclose(proposal_hash: H256, index: Compact<u32>, proposal_weight_bound: Compact<u64>, length_bound: Compact<u32>)\n\t\t\tdisapproveProposal(proposal_hash: H256)\n\t\t\texecute(proposal: Call, length_bound: Compact<u32>)\n\t\t\tpropose(threshold: Compact<u32>, proposal: Call, length_bound: Compact<u32>)\n\t\t\tsetMembers(new_members: Vec<AccountId32>, prime: Option<AccountId32>, old_count: u32)\n\t\t\tvote(proposal: H256, index: Compact<u32>, approve: bool)\n\t\t"},{name:"Democracy",rpc_path:"democracy",funcs:"\n\t\t\tblacklist(proposal_hash: H256, maybe_ref_index: Option<u32>)\n\t\t\tcancelProposal(prop_index: Compact<u32>)\n\t\t\tcancelQueued(which: u32)\n\t\t\tcancelReferendum(ref_index: Compact<u32>)\n\t\t\tclearPublicProposals()\n\t\t\tdelegate(to: AccountId32, conviction: PalletDemocracyConviction, balance: u128)\n\t\t\temergencyCancel(ref_index: u32)\n\t\t\tenactProposal(proposal_hash: H256, index: u32)\n\t\t\texternalPropose(proposal_hash: H256)\n\t\t\texternalProposeDefault(proposal_hash: H256)\n\t\t\texternalProposeMajority(proposal_hash: H256)\n\t\t\tfastTrack(proposal_hash: H256, voting_period: u32, delay: u32)\n\t\t\tnoteImminentPreimage(encoded_proposal: Bytes)\n\t\t\tnoteImminentPreimageOperational(encoded_proposal: Bytes)\n\t\t\tnotePreimage(encoded_proposal: Bytes)\n\t\t\tnotePreimageOperational(encoded_proposal: Bytes)\n\t\t\tpropose(proposal_hash: H256, value: Compact<u128>)\n\t\t\treapPreimage(proposal_hash: H256, proposal_len_upper_bound: Compact<u32>)\n\t\t\tremoveOtherVote(target: AccountId32, index: u32)\n\t\t\tremoveVote(index: u32)\n\t\t\tsecond(proposal: Compact<u32>, seconds_upper_bound: Compact<u32>)\n\t\t\tundelegate()\n\t\t\tunlock(target: AccountId32)\n\t\t\tvetoExternal(proposal_hash: H256)\n\t\t\tvote(ref_index: Compact<u32>, vote: PalletDemocracyVoteAccountVote)\n\t\t"},{name:"ElectionProviderMultiPhase",rpc_path:"electionProviderMultiPhase",funcs:"\n\t\t\tgovernanceFallback(maybe_max_voters: Option<u32>, maybe_max_targets: Option<u32>)\n\t\t\tsetEmergencyElectionResult(supports: Vec<(AccountId32,SpNposElectionsSupport)>)\n\t\t\tsetMinimumUntrustedScore(maybe_next_score: Option<[u128;3]>)\n\t\t\tsubmit(raw_solution: PalletElectionProviderMultiPhaseRawSolution, num_signed_submissions: u32)\n\t\t\tsubmitUnsigned(raw_solution: PalletElectionProviderMultiPhaseRawSolution, witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize)\n\t\t"},{name:"Elections",rpc_path:"elections",funcs:"\n\t\t\tcleanDefunctVoters(num_voters: u32, num_defunct: u32)\n\t\t\tremoveMember(who: MultiAddress, has_replacement: bool)\n\t\t\tremoveVoter()\n\t\t\trenounceCandidacy(renouncing: PalletElectionsPhragmenRenouncing)\n\t\t\tsubmitCandidacy(candidate_count: Compact<u32>)\n\t\t\tvote(votes: Vec<AccountId32>, value: Compact<u128>)\n\t\t"},{name:"Gilt",rpc_path:"gilt",funcs:"\n\t\t\tplaceBid(amount: Compact<u128>, duration: u32)\n\t\t\tretractBid(amount: Compact<u128>, duration: u32)\n\t\t\tsetTarget(target: Compact<Perquintill>)\n\t\t\tthaw(index: Compact<u32>)\n\t\t"},{name:"Grandpa",rpc_path:"grandpa",funcs:"\n\t\t\tnoteStalled(delay: u32, best_finalized_block_number: u32)\n\t\t\treportEquivocation(equivocation_proof: SpFinalityGrandpaEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t\treportEquivocationUnsigned(equivocation_proof: SpFinalityGrandpaEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t"},{name:"Identity",rpc_path:"identity",funcs:"\n\t\t\taddRegistrar(account: AccountId32)\n\t\t\taddSub(sub: MultiAddress, data: Data)\n\t\t\tcancelRequest(reg_index: u32)\n\t\t\tclearIdentity()\n\t\t\tkillIdentity(target: MultiAddress)\n\t\t\tprovideJudgement(reg_index: Compact<u32>, target: MultiAddress, judgement: PalletIdentityJudgement)\n\t\t\tquitSub()\n\t\t\tremoveSub(sub: MultiAddress)\n\t\t\trenameSub(sub: MultiAddress, data: Data)\n\t\t\trequestJudgement(reg_index: Compact<u32>, max_fee: Compact<u128>)\n\t\t\tsetAccountId(index: Compact<u32>, new: AccountId32)\n\t\t\tsetFee(index: Compact<u32>, fee: Compact<u128>)\n\t\t\tsetFields(index: Compact<u32>, fields: PalletIdentityBitFlags)\n\t\t\tsetIdentity(info: PalletIdentityIdentityInfo)\n\t\t\tsetSubs(subs: Vec<(AccountId32,Data)>)\n\t\t"},{name:"ImOnline",rpc_path:"imOnline",funcs:"\n\t\t\theartbeat(heartbeat: PalletImOnlineHeartbeat, signature: PalletImOnlineSr25519AppSr25519Signature)\n\t\t"},{name:"Indices",rpc_path:"indices",funcs:"\n\t\t\tclaim(index: u32)\n\t\t\tforceTransfer(new: AccountId32, index: u32, freeze: bool)\n\t\t\tfree(index: u32)\n\t\t\tfreeze(index: u32)\n\t\t\ttransfer(new: AccountId32, index: u32)\n\t\t"},{name:"Lottery",rpc_path:"lottery",funcs:"\n\t\t\tbuyTicket(call: Call)\n\t\t\tsetCalls(calls: Vec<Call>)\n\t\t\tstartLottery(price: u128, length: u32, delay: u32, repeat: bool)\n\t\t\tstopRepeat()\n\t\t"},{name:"Multisig",rpc_path:"multisig",funcs:"\n\t\t\tapproveAsMulti(threshold: u16, other_signatories: Vec<AccountId32>, maybe_timepoint: Option<PalletMultisigTimepoint>, call_hash: [u8;32], max_weight: u64)\n\t\t\tasMulti(threshold: u16, other_signatories: Vec<AccountId32>, maybe_timepoint: Option<PalletMultisigTimepoint>, call: WrapperKeepOpaque<Call>, store_call: bool, max_weight: u64)\n\t\t\tasMultiThreshold1(other_signatories: Vec<AccountId32>, call: Call)\n\t\t\tcancelAsMulti(threshold: u16, other_signatories: Vec<AccountId32>, timepoint: PalletMultisigTimepoint, call_hash: [u8;32])\n\t\t"},{name:"Preimage",rpc_path:"preimage",funcs:"\n\t\t\tnotePreimage(bytes: Bytes)\n\t\t\trequestPreimage(hash: H256)\n\t\t\tunnotePreimage(hash: H256)\n\t\t\tunrequestPreimage(hash: H256)\n\t\t"},{name:"Proxy",rpc_path:"proxy",funcs:"\n\t\t\taddProxy(delegate: AccountId32, proxy_type: NodeRuntimeProxyType, delay: u32)\n\t\t\tannounce(real: AccountId32, call_hash: H256)\n\t\t\tanonymous(proxy_type: NodeRuntimeProxyType, delay: u32, index: u16)\n\t\t\tkillAnonymous(spawner: AccountId32, proxy_type: NodeRuntimeProxyType, index: u16, height: Compact<u32>, ext_index: Compact<u32>)\n\t\t\tproxy(real: AccountId32, force_proxy_type: Option<NodeRuntimeProxyType>, call: Call)\n\t\t\tproxyAnnounced(delegate: AccountId32, real: AccountId32, force_proxy_type: Option<NodeRuntimeProxyType>, call: Call)\n\t\t\trejectAnnouncement(delegate: AccountId32, call_hash: H256)\n\t\t\tremoveAnnouncement(real: AccountId32, call_hash: H256)\n\t\t\tremoveProxies()\n\t\t\tremoveProxy(delegate: AccountId32, proxy_type: NodeRuntimeProxyType, delay: u32)\n\t\t"},{name:"Recovery",rpc_path:"recovery",funcs:"\n\t\t\tasRecovered(account: AccountId32, call: Call)\n\t\t\tcancelRecovered(account: AccountId32)\n\t\t\tclaimRecovery(account: AccountId32)\n\t\t\tcloseRecovery(rescuer: AccountId32)\n\t\t\tcreateRecovery(friends: Vec<AccountId32>, threshold: u16, delay_period: u32)\n\t\t\tinitiateRecovery(account: AccountId32)\n\t\t\tremoveRecovery()\n\t\t\tsetRecovered(lost: AccountId32, rescuer: AccountId32)\n\t\t\tvouchRecovery(lost: AccountId32, rescuer: AccountId32)\n\t\t"},{name:"Scheduler",rpc_path:"scheduler",funcs:"\n\t\t\tcancel(when: u32, index: u32)\n\t\t\tcancelNamed(id: Bytes)\n\t\t\tschedule(when: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t\tscheduleAfter(after: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t\tscheduleNamed(id: Bytes, when: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t\tscheduleNamedAfter(id: Bytes, after: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t"},{name:"Session",rpc_path:"session",funcs:"\n\t\t\tpurgeKeys()\n\t\t\tsetKeys(keys: NodeRuntimeSessionKeys, proof: Bytes)\n\t\t"},{name:"Society",rpc_path:"society",funcs:"\n\t\t\tbid(value: u128)\n\t\t\tdefenderVote(approve: bool)\n\t\t\tfound(founder: AccountId32, max_members: u32, rules: Bytes)\n\t\t\tjudgeSuspendedCandidate(who: AccountId32, judgement: PalletSocietyJudgement)\n\t\t\tjudgeSuspendedMember(who: AccountId32, forgive: bool)\n\t\t\tpayout()\n\t\t\tsetMaxMembers(max: u32)\n\t\t\tunbid(pos: u32)\n\t\t\tunfound()\n\t\t\tunvouch(pos: u32)\n\t\t\tvote(candidate: MultiAddress, approve: bool)\n\t\t\tvouch(who: AccountId32, value: u128, tip: u128)\n\t\t"},{name:"Staking",rpc_path:"staking",funcs:"\n\t\t\tbond(controller: MultiAddress, value: Compact<u128>, payee: PalletStakingRewardDestination)\n\t\t\tbondExtra(max_additional: Compact<u128>)\n\t\t\tcancelDeferredSlash(era: u32, slash_indices: Vec<u32>)\n\t\t\tchill()\n\t\t\tchillOther(controller: AccountId32)\n\t\t\tforceNewEra()\n\t\t\tforceNewEraAlways()\n\t\t\tforceNoEras()\n\t\t\tforceUnstake(stash: AccountId32, num_slashing_spans: u32)\n\t\t\tincreaseValidatorCount(additional: Compact<u32>)\n\t\t\tkick(who: Vec<MultiAddress>)\n\t\t\tnominate(targets: Vec<MultiAddress>)\n\t\t\tpayoutStakers(validator_stash: AccountId32, era: u32)\n\t\t\treapStash(stash: AccountId32, num_slashing_spans: u32)\n\t\t\trebond(value: Compact<u128>)\n\t\t\tscaleValidatorCount(factor: Percent)\n\t\t\tsetController(controller: MultiAddress)\n\t\t\tsetHistoryDepth(new_history_depth: Compact<u32>, era_items_deleted: Compact<u32>)\n\t\t\tsetInvulnerables(invulnerables: Vec<AccountId32>)\n\t\t\tsetPayee(payee: PalletStakingRewardDestination)\n\t\t\tsetStakingConfigs(min_nominator_bond: u128, min_validator_bond: u128, max_nominator_count: Option<u32>, max_validator_count: Option<u32>, chill_threshold: Option<Percent>, min_commission: Perbill)\n\t\t\tsetValidatorCount(new: Compact<u32>)\n\t\t\tunbond(value: Compact<u128>)\n\t\t\tvalidate(prefs: PalletStakingValidatorPrefs)\n\t\t\twithdrawUnbonded(num_slashing_spans: u32)\n\t\t"},{name:"Sudo",rpc_path:"sudo",funcs:"\n\t\t\tsetKey(new: MultiAddress)\n\t\t\tsudo(call: Call)\n\t\t\tsudoAs(who: MultiAddress, call: Call)\n\t\t\tsudoUncheckedWeight(call: Call, weight: u64)\n\t\t"},{name:"System",rpc_path:"system",funcs:"\n\t\t\tfillBlock(ratio: Perbill)\n\t\t\tkillPrefix(prefix: Bytes, subkeys: u32)\n\t\t\tkillStorage(keys: Vec<Bytes>)\n\t\t\tremark(remark: Bytes)\n\t\t\tremarkWithEvent(remark: Bytes)\n\t\t\tsetCode(code: Bytes)\n\t\t\tsetCodeWithoutChecks(code: Bytes)\n\t\t\tsetHeapPages(pages: u64)\n\t\t\tsetStorage(items: Vec<(Bytes,Bytes)>)\n\t\t"},{name:"TechnicalCommittee",rpc_path:"technicalCommittee",funcs:"\n\t\t\tclose(proposal_hash: H256, index: Compact<u32>, proposal_weight_bound: Compact<u64>, length_bound: Compact<u32>)\n\t\t\tdisapproveProposal(proposal_hash: H256)\n\t\t\texecute(proposal: Call, length_bound: Compact<u32>)\n\t\t\tpropose(threshold: Compact<u32>, proposal: Call, length_bound: Compact<u32>)\n\t\t\tsetMembers(new_members: Vec<AccountId32>, prime: Option<AccountId32>, old_count: u32)\n\t\t\tvote(proposal: H256, index: Compact<u32>, approve: bool)\n\t\t"},{name:"TechnicalMembership",rpc_path:"technicalMembership",funcs:"\n\t\t\taddMember(who: AccountId32)\n\t\t\tchangeKey(new: AccountId32)\n\t\t\tclearPrime()\n\t\t\tremoveMember(who: AccountId32)\n\t\t\tresetMembers(members: Vec<AccountId32>)\n\t\t\tsetPrime(who: AccountId32)\n\t\t\tswapMember(remove: AccountId32, add: AccountId32)\n\t\t"},{name:"Timestamp",rpc_path:"timestamp",funcs:"\n\t\t\tset(now: Compact<u64>)\n\t\t"},{name:"Tips",rpc_path:"tips",funcs:"\n\t\t\tcloseTip(hash: H256)\n\t\t\treportAwesome(reason: Bytes, who: AccountId32)\n\t\t\tretractTip(hash: H256)\n\t\t\tslashTip(hash: H256)\n\t\t\ttip(hash: H256, tip_value: Compact<u128>)\n\t\t\ttipNew(reason: Bytes, who: AccountId32, tip_value: Compact<u128>)\n\t\t"},{name:"TransactionStorage",rpc_path:"transactionStorage",funcs:"\n\t\t\tcheckProof(proof: SpTransactionStorageProofTransactionStorageProof)\n\t\t\trenew(block: u32, index: u32)\n\t\t\tstore(data: Bytes)\n\t\t"},{name:"Treasury",rpc_path:"treasury",funcs:"\n\t\t\tapproveProposal(proposal_id: Compact<u32>)\n\t\t\tproposeSpend(value: Compact<u128>, beneficiary: MultiAddress)\n\t\t\trejectProposal(proposal_id: Compact<u32>)\n\t\t"},{name:"Uniques",rpc_path:"uniques",funcs:"\n\t\t\tapproveTransfer(class: Compact<u32>, instance: Compact<u32>, delegate: MultiAddress)\n\t\t\tburn(class: Compact<u32>, instance: Compact<u32>, check_owner: Option<MultiAddress>)\n\t\t\tcancelApproval(class: Compact<u32>, instance: Compact<u32>, maybe_check_delegate: Option<MultiAddress>)\n\t\t\tclearAttribute(class: Compact<u32>, maybe_instance: Option<u32>, key: Bytes)\n\t\t\tclearClassMetadata(class: Compact<u32>)\n\t\t\tclearMetadata(class: Compact<u32>, instance: Compact<u32>)\n\t\t\tcreate(class: Compact<u32>, admin: MultiAddress)\n\t\t\tdestroy(class: Compact<u32>, witness: PalletUniquesDestroyWitness)\n\t\t\tforceAssetStatus(class: Compact<u32>, owner: MultiAddress, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress, free_holding: bool, is_frozen: bool)\n\t\t\tforceCreate(class: Compact<u32>, owner: MultiAddress, free_holding: bool)\n\t\t\tfreeze(class: Compact<u32>, instance: Compact<u32>)\n\t\t\tfreezeClass(class: Compact<u32>)\n\t\t\tmint(class: Compact<u32>, instance: Compact<u32>, owner: MultiAddress)\n\t\t\tredeposit(class: Compact<u32>, instances: Vec<u32>)\n\t\t\tsetAttribute(class: Compact<u32>, maybe_instance: Option<u32>, key: Bytes, value: Bytes)\n\t\t\tsetClassMetadata(class: Compact<u32>, data: Bytes, is_frozen: bool)\n\t\t\tsetMetadata(class: Compact<u32>, instance: Compact<u32>, data: Bytes, is_frozen: bool)\n\t\t\tsetTeam(class: Compact<u32>, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress)\n\t\t\tthaw(class: Compact<u32>, instance: Compact<u32>)\n\t\t\tthawClass(class: Compact<u32>)\n\t\t\ttransfer(class: Compact<u32>, instance: Compact<u32>, dest: MultiAddress)\n\t\t\ttransferOwnership(class: Compact<u32>, owner: MultiAddress)\n\t\t"},{name:"Utility",rpc_path:"utility",funcs:"\n\t\t\tasDerivative(index: u16, call: Call)\n\t\t\tbatch(calls: Vec<Call>)\n\t\t\tbatchAll(calls: Vec<Call>)\n\t\t\tdispatchAs(as_origin: NodeRuntimeOriginCaller, call: Call)\n\t\t"},{name:"Vesting",rpc_path:"vesting",funcs:"\n\t\t\tforceVestedTransfer(source: MultiAddress, target: MultiAddress, schedule: PalletVestingVestingInfo)\n\t\t\tmergeSchedules(schedule1_index: u32, schedule2_index: u32)\n\t\t\tvest()\n\t\t\tvestOther(target: MultiAddress)\n\t\t\tvestedTransfer(target: MultiAddress, schedule: PalletVestingVestingInfo)\n\t\t"}]),T.registerNode("Polkadot.js/Keyring/Dummy",((l=class extends T.Node{constructor(t){super(t);let e=this.setInterface();e.title="Dummy Key",e.description="Randomly generated wallet"}imported(){this.update()}update(){let{Input:t,Output:e}=this.ref;e.Seed=O.randomAsU8a(32);let n=new x.Keyring({type:t.KeyType,ss58Format:0}),a=e.Pair=n.addFromSeed(e.Seed);e.Signer=new D(!0,e.Address,a),e.Address=a.address}}).input={KeyType:T.Port.Default(String,"ed25519")},l.output={Address:String,Seed:Uint8Array,Signer:D,Pair:Object},l)),j({namespace:"Storage",description:"[Experimental] Substrate Storage",apiPath:"query",loose:!0,typeAsName:!0},[{name:"Assets",rpc_path:"assets",funcs:"\n\t\t\taccount(u32, AccountId32): Option<PalletAssetsAssetAccount>\n\t\t\tapprovals(u32, AccountId32, AccountId32): Option<PalletAssetsApproval>\n\t\t\tasset(u32): Option<PalletAssetsAssetDetails>\n\t\t\tmetadata(u32): PalletAssetsAssetMetadata\n\t\t"},{name:"AuthorityDiscovery",rpc_path:"authorityDiscovery",funcs:"\n\t\t\tkeys(): Vec<SpAuthorityDiscoveryAppPublic>\n\t\t\tnextKeys(): Vec<SpAuthorityDiscoveryAppPublic>\n\t\t"},{name:"Authorship",rpc_path:"authorship",funcs:"\n\t\t\tauthor(): Option<AccountId32>\n\t\t\tdidSetUncles(): bool\n\t\t\tuncles(): Vec<PalletAuthorshipUncleEntryItem>\n\t\t"},{name:"Babe",rpc_path:"babe",funcs:"\n\t\t\tauthorities(): Vec<(SpConsensusBabeAppPublic,u64)>\n\t\t\tauthorVrfRandomness(): Option<[u8;32]>\n\t\t\tcurrentSlot(): u64\n\t\t\tepochConfig(): Option<SpConsensusBabeBabeEpochConfiguration>\n\t\t\tepochIndex(): u64\n\t\t\tepochStart(): (u32,u32)\n\t\t\tgenesisSlot(): u64\n\t\t\tinitialized(): Option<Option<[u8;32]>>\n\t\t\tlateness(): u32\n\t\t\tnextAuthorities(): Vec<(SpConsensusBabeAppPublic,u64)>\n\t\t\tnextEpochConfig(): Option<SpConsensusBabeBabeEpochConfiguration>\n\t\t\tnextRandomness(): [u8;32]\n\t\t\tpendingEpochConfigChange(): Option<SpConsensusBabeDigestsNextConfigDescriptor>\n\t\t\trandomness(): [u8;32]\n\t\t\tsegmentIndex(): u32\n\t\t\tunderConstruction(u32): Vec<[u8;32]>\n\t\t"},{name:"BagsList",rpc_path:"bagsList",funcs:"\n\t\t\tcounterForListNodes(): u32\n\t\t\tlistBags(u64): Option<PalletBagsListListBag>\n\t\t\tlistNodes(AccountId32): Option<PalletBagsListListNode>\n\t\t"},{name:"Balances",rpc_path:"balances",funcs:"\n\t\t\taccount(AccountId32): PalletBalancesAccountData\n\t\t\tlocks(AccountId32): Vec<PalletBalancesBalanceLock>\n\t\t\treserves(AccountId32): Vec<PalletBalancesReserveData>\n\t\t\tstorageVersion(): PalletBalancesReleases\n\t\t\ttotalIssuance(): u128\n\t\t"},{name:"Bounties",rpc_path:"bounties",funcs:"\n\t\t\tbounties(u32): Option<PalletBountiesBounty>\n\t\t\tbountyApprovals(): Vec<u32>\n\t\t\tbountyCount(): u32\n\t\t\tbountyDescriptions(u32): Option<Bytes>\n\t\t"},{name:"ChildBounties",rpc_path:"childBounties",funcs:"\n\t\t\tchildBounties(u32, u32): Option<PalletChildBountiesChildBounty>\n\t\t\tchildBountyCount(): u32\n\t\t\tchildBountyDescriptions(u32): Option<Bytes>\n\t\t\tchildrenCuratorFees(u32): u128\n\t\t\tparentChildBounties(u32): u32\n\t\t"},{name:"Contracts",rpc_path:"contracts",funcs:"\n\t\t\taccountCounter(): u64\n\t\t\tcodeStorage(H256): Option<PalletContractsWasmPrefabWasmModule>\n\t\t\tcontractInfoOf(AccountId32): Option<PalletContractsStorageRawContractInfo>\n\t\t\tdeletionQueue(): Vec<PalletContractsStorageDeletedContract>\n\t\t\townerInfoOf(H256): Option<PalletContractsWasmOwnerInfo>\n\t\t\tpristineCode(H256): Option<Bytes>\n\t\t"},{name:"Council",rpc_path:"council",funcs:"\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tprime(): Option<AccountId32>\n\t\t\tproposalCount(): u32\n\t\t\tproposalOf(H256): Option<Call>\n\t\t\tproposals(): Vec<H256>\n\t\t\tvoting(H256): Option<PalletCollectiveVotes>\n\t\t"},{name:"Democracy",rpc_path:"democracy",funcs:"\n\t\t\tblacklist(H256): Option<(u32,Vec<AccountId32>)>\n\t\t\tcancellations(H256): bool\n\t\t\tdepositOf(u32): Option<(Vec<AccountId32>,u128)>\n\t\t\tlastTabledWasExternal(): bool\n\t\t\tlocks(AccountId32): Option<u32>\n\t\t\tlowestUnbaked(): u32\n\t\t\tnextExternal(): Option<(H256,PalletDemocracyVoteThreshold)>\n\t\t\tpreimages(H256): Option<PalletDemocracyPreimageStatus>\n\t\t\tpublicPropCount(): u32\n\t\t\tpublicProps(): Vec<(u32,H256,AccountId32)>\n\t\t\treferendumCount(): u32\n\t\t\treferendumInfoOf(u32): Option<PalletDemocracyReferendumInfo>\n\t\t\tstorageVersion(): Option<PalletDemocracyReleases>\n\t\t\tvotingOf(AccountId32): PalletDemocracyVoteVoting\n\t\t"},{name:"ElectionProviderMultiPhase",rpc_path:"electionProviderMultiPhase",funcs:"\n\t\t\tcurrentPhase(): PalletElectionProviderMultiPhasePhase\n\t\t\tdesiredTargets(): Option<u32>\n\t\t\tminimumUntrustedScore(): Option<[u128;3]>\n\t\t\tqueuedSolution(): Option<PalletElectionProviderMultiPhaseReadySolution>\n\t\t\tround(): u32\n\t\t\tsignedSubmissionIndices(): BTreeMap<[u128;3], u32>\n\t\t\tsignedSubmissionNextIndex(): u32\n\t\t\tsignedSubmissionsMap(u32): Option<PalletElectionProviderMultiPhaseSignedSignedSubmission>\n\t\t\tsnapshot(): Option<PalletElectionProviderMultiPhaseRoundSnapshot>\n\t\t\tsnapshotMetadata(): Option<PalletElectionProviderMultiPhaseSolutionOrSnapshotSize>\n\t\t"},{name:"Elections",rpc_path:"elections",funcs:"\n\t\t\tcandidates(): Vec<(AccountId32,u128)>\n\t\t\telectionRounds(): u32\n\t\t\tmembers(): Vec<PalletElectionsPhragmenSeatHolder>\n\t\t\trunnersUp(): Vec<PalletElectionsPhragmenSeatHolder>\n\t\t\tvoting(AccountId32): PalletElectionsPhragmenVoter\n\t\t"},{name:"Gilt",rpc_path:"gilt",funcs:"\n\t\t\tactive(u32): Option<PalletGiltActiveGilt>\n\t\t\tactiveTotal(): PalletGiltActiveGiltsTotal\n\t\t\tqueues(u32): Vec<PalletGiltGiltBid>\n\t\t\tqueueTotals(): Vec<(u32,u128)>\n\t\t"},{name:"Grandpa",rpc_path:"grandpa",funcs:"\n\t\t\tcurrentSetId(): u64\n\t\t\tnextForced(): Option<u32>\n\t\t\tpendingChange(): Option<PalletGrandpaStoredPendingChange>\n\t\t\tsetIdSession(u64): Option<u32>\n\t\t\tstalled(): Option<(u32,u32)>\n\t\t\tstate(): PalletGrandpaStoredState\n\t\t"},{name:"Identity",rpc_path:"identity",funcs:"\n\t\t\tidentityOf(AccountId32): Option<PalletIdentityRegistration>\n\t\t\tregistrars(): Vec<Option<PalletIdentityRegistrarInfo>>\n\t\t\tsubsOf(AccountId32): (u128,Vec<AccountId32>)\n\t\t\tsuperOf(AccountId32): Option<(AccountId32,Data)>\n\t\t"},{name:"ImOnline",rpc_path:"imOnline",funcs:"\n\t\t\tauthoredBlocks(u32, AccountId32): u32\n\t\t\theartbeatAfter(): u32\n\t\t\tkeys(): Vec<PalletImOnlineSr25519AppSr25519Public>\n\t\t\treceivedHeartbeats(u32, u32): Option<WrapperOpaque<PalletImOnlineBoundedOpaqueNetworkState>>\n\t\t"},{name:"Indices",rpc_path:"indices",funcs:"\n\t\t\taccounts(u32): Option<(AccountId32,u128,bool)>\n\t\t"},{name:"Lottery",rpc_path:"lottery",funcs:"\n\t\t\tcallIndices(): Vec<(u8,u8)>\n\t\t\tlottery(): Option<PalletLotteryLotteryConfig>\n\t\t\tlotteryIndex(): u32\n\t\t\tparticipants(AccountId32): (u32,Vec<(u8,u8)>)\n\t\t\ttickets(u32): Option<AccountId32>\n\t\t\tticketsCount(): u32\n\t\t"},{name:"Mmr",rpc_path:"mmr",funcs:"\n\t\t\tnodes(u64): Option<H256>\n\t\t\tnumberOfLeaves(): u64\n\t\t\trootHash(): H256\n\t\t"},{name:"Multisig",rpc_path:"multisig",funcs:"\n\t\t\tcalls([u8;32]): Option<(WrapperKeepOpaque<Call>,AccountId32,u128)>\n\t\t\tmultisigs(AccountId32, [u8;32]): Option<PalletMultisigMultisig>\n\t\t"},{name:"Offences",rpc_path:"offences",funcs:"\n\t\t\tconcurrentReportsIndex([u8;16], Bytes): Vec<H256>\n\t\t\treports(H256): Option<SpStakingOffenceOffenceDetails>\n\t\t\treportsByKindIndex([u8;16]): Bytes\n\t\t"},{name:"Preimage",rpc_path:"preimage",funcs:"\n\t\t\tpreimageFor(H256): Option<Bytes>\n\t\t\tstatusFor(H256): Option<PalletPreimageRequestStatus>\n\t\t"},{name:"Proxy",rpc_path:"proxy",funcs:"\n\t\t\tannouncements(AccountId32): (Vec<PalletProxyAnnouncement>,u128)\n\t\t\tproxies(AccountId32): (Vec<PalletProxyProxyDefinition>,u128)\n\t\t"},{name:"RandomnessCollectiveFlip",rpc_path:"randomnessCollectiveFlip",funcs:"\n\t\t\trandomMaterial(): Vec<H256>\n\t\t"},{name:"Recovery",rpc_path:"recovery",funcs:"\n\t\t\tactiveRecoveries(AccountId32, AccountId32): Option<PalletRecoveryActiveRecovery>\n\t\t\tproxy(AccountId32): Option<AccountId32>\n\t\t\trecoverable(AccountId32): Option<PalletRecoveryRecoveryConfig>\n\t\t"},{name:"Scheduler",rpc_path:"scheduler",funcs:"\n\t\t\tagenda(u32): Vec<Option<PalletSchedulerScheduledV3>>\n\t\t\tlookup(Bytes): Option<(u32,u32)>\n\t\t"},{name:"Session",rpc_path:"session",funcs:"\n\t\t\tcurrentIndex(): u32\n\t\t\tdisabledValidators(): Vec<u32>\n\t\t\tkeyOwner((SpCoreCryptoKeyTypeId,Bytes)): Option<AccountId32>\n\t\t\tnextKeys(AccountId32): Option<NodeRuntimeSessionKeys>\n\t\t\tqueuedChanged(): bool\n\t\t\tqueuedKeys(): Vec<(AccountId32,NodeRuntimeSessionKeys)>\n\t\t\tvalidators(): Vec<AccountId32>\n\t\t"},{name:"Society",rpc_path:"society",funcs:"\n\t\t\tbids(): Vec<PalletSocietyBid>\n\t\t\tcandidates(): Vec<PalletSocietyBid>\n\t\t\tdefender(): Option<AccountId32>\n\t\t\tdefenderVotes(AccountId32): Option<PalletSocietyVote>\n\t\t\tfounder(): Option<AccountId32>\n\t\t\thead(): Option<AccountId32>\n\t\t\tmaxMembers(): u32\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tpayouts(AccountId32): Vec<(u32,u128)>\n\t\t\tpot(): u128\n\t\t\trules(): Option<H256>\n\t\t\tstrikes(AccountId32): u32\n\t\t\tsuspendedCandidates(AccountId32): Option<(u128,PalletSocietyBidKind)>\n\t\t\tsuspendedMembers(AccountId32): bool\n\t\t\tvotes(AccountId32, AccountId32): Option<PalletSocietyVote>\n\t\t\tvouching(AccountId32): Option<PalletSocietyVouchingStatus>\n\t\t"},{name:"Staking",rpc_path:"staking",funcs:"\n\t\t\tactiveEra(): Option<PalletStakingActiveEraInfo>\n\t\t\tbonded(AccountId32): Option<AccountId32>\n\t\t\tbondedEras(): Vec<(u32,u32)>\n\t\t\tcanceledSlashPayout(): u128\n\t\t\tchillThreshold(): Option<Percent>\n\t\t\tcounterForNominators(): u32\n\t\t\tcounterForValidators(): u32\n\t\t\tcurrentEra(): Option<u32>\n\t\t\tcurrentPlannedSession(): u32\n\t\t\tearliestUnappliedSlash(): Option<u32>\n\t\t\terasRewardPoints(u32): PalletStakingEraRewardPoints\n\t\t\terasStakers(u32, AccountId32): PalletStakingExposure\n\t\t\terasStakersClipped(u32, AccountId32): PalletStakingExposure\n\t\t\terasStartSessionIndex(u32): Option<u32>\n\t\t\terasTotalStake(u32): u128\n\t\t\terasValidatorPrefs(u32, AccountId32): PalletStakingValidatorPrefs\n\t\t\terasValidatorReward(u32): Option<u128>\n\t\t\tforceEra(): PalletStakingForcing\n\t\t\thistoryDepth(): u32\n\t\t\tinvulnerables(): Vec<AccountId32>\n\t\t\tledger(AccountId32): Option<PalletStakingStakingLedger>\n\t\t\tmaxNominatorsCount(): Option<u32>\n\t\t\tmaxValidatorsCount(): Option<u32>\n\t\t\tminCommission(): Perbill\n\t\t\tminimumValidatorCount(): u32\n\t\t\tminNominatorBond(): u128\n\t\t\tminValidatorBond(): u128\n\t\t\tnominators(AccountId32): Option<PalletStakingNominations>\n\t\t\tnominatorSlashInEra(u32, AccountId32): Option<u128>\n\t\t\toffendingValidators(): Vec<(u32,bool)>\n\t\t\tpayee(AccountId32): PalletStakingRewardDestination\n\t\t\tslashingSpans(AccountId32): Option<PalletStakingSlashingSlashingSpans>\n\t\t\tslashRewardFraction(): Perbill\n\t\t\tspanSlash((AccountId32,u32)): PalletStakingSlashingSpanRecord\n\t\t\tstorageVersion(): PalletStakingReleases\n\t\t\tunappliedSlashes(u32): Vec<PalletStakingUnappliedSlash>\n\t\t\tvalidatorCount(): u32\n\t\t\tvalidators(AccountId32): PalletStakingValidatorPrefs\n\t\t\tvalidatorSlashInEra(u32, AccountId32): Option<(Perbill,u128)>\n\t\t"},{name:"Substrate",rpc_path:"substrate",funcs:"\n\t\t\tchangesTrieConfig(): u32\n\t\t\tchildStorageKeyPrefix(): u32\n\t\t\tcode(): Bytes\n\t\t\textrinsicIndex(): u32\n\t\t\theapPages(): u64\n\t\t"},{name:"Sudo",rpc_path:"sudo",funcs:"\n\t\t\tkey(): Option<AccountId32>\n\t\t"},{name:"System",rpc_path:"system",funcs:"\n\t\t\taccount(AccountId32): FrameSystemAccountInfo\n\t\t\tallExtrinsicsLen(): Option<u32>\n\t\t\tblockHash(u32): H256\n\t\t\tblockWeight(): FrameSupportWeightsPerDispatchClassU64\n\t\t\tdigest(): SpRuntimeDigest\n\t\t\teventCount(): u32\n\t\t\tevents(): Vec<FrameSystemEventRecord>\n\t\t\teventTopics(H256): Vec<(u32,u32)>\n\t\t\texecutionPhase(): Option<FrameSystemPhase>\n\t\t\textrinsicCount(): Option<u32>\n\t\t\textrinsicData(u32): Bytes\n\t\t\tlastRuntimeUpgrade(): Option<FrameSystemLastRuntimeUpgradeInfo>\n\t\t\tnumber(): u32\n\t\t\tparentHash(): H256\n\t\t\tupgradedToTripleRefCount(): bool\n\t\t\tupgradedToU32RefCount(): bool\n\t\t"},{name:"TechnicalCommittee",rpc_path:"technicalCommittee",funcs:"\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tprime(): Option<AccountId32>\n\t\t\tproposalCount(): u32\n\t\t\tproposalOf(H256): Option<Call>\n\t\t\tproposals(): Vec<H256>\n\t\t\tvoting(H256): Option<PalletCollectiveVotes>\n\t\t"},{name:"TechnicalMembership",rpc_path:"technicalMembership",funcs:"\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tprime(): Option<AccountId32>\n\t\t"},{name:"Timestamp",rpc_path:"timestamp",funcs:"\n\t\t\tdidUpdate(): bool\n\t\t\tnow(): u64\n\t\t"},{name:"Tips",rpc_path:"tips",funcs:"\n\t\t\treasons(H256): Option<Bytes>\n\t\t\ttips(H256): Option<PalletTipsOpenTip>\n\t\t"},{name:"TransactionPayment",rpc_path:"transactionPayment",funcs:"\n\t\t\tnextFeeMultiplier(): u128\n\t\t\tstorageVersion(): PalletTransactionPaymentReleases\n\t\t"},{name:"TransactionStorage",rpc_path:"transactionStorage",funcs:"\n\t\t\tblockTransactions(): Vec<PalletTransactionStorageTransactionInfo>\n\t\t\tbyteFee(): Option<u128>\n\t\t\tchunkCount(u32): u32\n\t\t\tentryFee(): Option<u128>\n\t\t\tmaxBlockTransactions(): u32\n\t\t\tmaxTransactionSize(): u32\n\t\t\tproofChecked(): bool\n\t\t\tstoragePeriod(): u32\n\t\t\ttransactions(u32): Option<Vec<PalletTransactionStorageTransactionInfo>>\n\t\t"},{name:"Treasury",rpc_path:"treasury",funcs:"\n\t\t\tapprovals(): Vec<u32>\n\t\t\tproposalCount(): u32\n\t\t\tproposals(u32): Option<PalletTreasuryProposal>\n\t\t"},{name:"Uniques",rpc_path:"uniques",funcs:"\n\t\t\taccount(AccountId32, u32, u32): Option<Null>\n\t\t\tasset(u32, u32): Option<PalletUniquesInstanceDetails>\n\t\t\tattribute(u32, Option<u32>, Bytes): Option<(Bytes,u128)>\n\t\t\tclass(u32): Option<PalletUniquesClassDetails>\n\t\t\tclassAccount(AccountId32, u32): Option<Null>\n\t\t\tclassMetadataOf(u32): Option<PalletUniquesClassMetadata>\n\t\t\tinstanceMetadataOf(u32, u32): Option<PalletUniquesInstanceMetadata>\n\t\t"},{name:"Vesting",rpc_path:"vesting",funcs:"\n\t\t\tstorageVersion(): PalletVestingReleases\n\t\t\tvesting(AccountId32): Option<Vec<PalletVestingVestingInfo>>\n\t\t"}]),T.registerNode("Polkadot.js/Transaction/DryRun",((d=class extends T.Node{constructor(t){super(t);let e=this.setInterface();e.title="Dry Run Transaction",e.description="Try a transaction but not actually execute it"}imported(){let{Input:t,Output:e,IInput:n,IOutput:a}=this.ref,o=new N(this.iface);function s(t){e.Status=t}async function r(){if(null===t.Provider)return o.warn("Provider is required");if(null===t.Signer)return o.warn("Signer is required");if(null===t.Txn)return o.warn("Txn is required");o.clear();let e=t.Signer,n=t.Txn.txn;try{e.isPair?await n.dryRun(e.signer,s):await n.dryRun(e.address,{signer:e.signer},s)}catch(t){throw console.log(o,t),o.error(t.message),t}}this.iface.on("port.value",E.EventSlot,r),this.iface.on("cable.disconnect",E.EventSlot,(function({port:t}){"input"===t.source&&r()}))}}).input={Provider:T.Port.Union([x.WsProvider,x.HttpProvider]),Signer:D,Txn:R},d.output={Status:Object},d)),T.registerNode("Polkadot.js/Transaction/PaymentInfo",((p=class extends T.Node{constructor(t){super(t),this.setInterface().title="Txn Payment Info"}imported(){let{Input:t,Output:e,IInput:n,IOutput:a}=this.ref,o=new N(this.iface);async function s(){if(null===t.Provider)return o.warn("Provider is required");if(null===t.Signer)return o.warn("Signer is required");if(null===t.Txn)return o.warn("Txn is required");o.clear();let n,a=t.Signer,s=t.Txn.txn;try{n=a.isPair?await s.paymentInfo(a.signer):await s.paymentInfo(a.address,{signer:a.signer})}catch(t){throw o.error(t.message),t}e.Info=n}this.iface.on("port.value",E.EventSlot,s),this.iface.on("cable.disconnect",E.EventSlot,(function({port:t}){"input"===t.source&&s()}))}}).input={Provider:T.Port.Union([x.WsProvider,x.HttpProvider]),Signer:D,Txn:R},p.output={Info:Object},p)),T.registerNode("Polkadot.js/Transaction/Send",((h=class extends T.Node{constructor(t){super(t),this.setInterface().title="Send Transaction"}imported(){let{Input:t,Output:e,IInput:n,IOutput:a}=this.ref,o=new N(this.iface);function s(t){e.Status=t}let r=this.submit=async function(e){if(null===t.Provider)return o.warn("Provider is required");if(null===t.Signer)return o.warn("Signer is required");if(null===t.Txn)return o.warn("Txn is required");if(o.clear(),!0!==e)return;let n=t.Signer,a=t.Txn.txn;try{n.isPair?await a.signAndSend(n.signer,s):await a.signAndSend(n.address,{signer:n.signer},s)}catch(t){throw o.error(t.message),t}};this.iface.on("port.value",E.EventSlot,r),this.iface.on("cable.disconnect",E.EventSlot,(function({port:t}){"input"===t.source&&r()}))}}).input={Submit:T.Port.Trigger((function(){this.submit(!0)})),Provider:T.Port.Union([x.WsProvider,x.HttpProvider]),Signer:D,Txn:R},h.output={Status:Object},h)),T.registerNode("Polkadot.js/Convert/Address To/Address",((m=class extends T.Node{constructor(t){super(t),this.setInterface().title="Address to Address",this._toast=new N(this.iface)}init(){this.iface.on("cable.disconnect",E.EventSlot,(()=>this.update()))}_fail(t){this.output.Address=null,this._toast.warn(t)}update(){let{Input:t,Output:e}=this.ref;return t.Address?t.ChainId?(this._toast.clear(),void(e.Address=k.encodeAddress(t.Address,t.ChainId))):this._fail("ChainId is required"):this._fail("Address is required")}}).output={Address:String},m.input={Address:String,ChainId:Number},m)),T.registerNode("Polkadot.js/Convert/Address To/Uint8Array",((y=class extends T.Node{constructor(t){super(t),this.setInterface().title="Address to Address",this._toast=new N(this.iface)}init(){this.iface.on("cable.disconnect",E.EventSlot,(()=>this.update()))}_fail(t){this.output.Bytes=null,this._toast.warn(t)}update(){let{Input:t,Output:e}=this.ref;if(!t.Address)return this._fail("Address is required");this._toast.clear(),e.Bytes=k.decodeAddress(t.Address)}}).output={Bytes:Uint8Array},y.input={Address:String},y)),T.registerNode("Polkadot.js/Convert/String To/Uint8Array",((g=class extends T.Node{constructor(t){super(t),this.setInterface().title="String to Uint8Array"}init(){this.iface.input.In.on("disconnect",E.EventSlot,(()=>{this.output.Out=null}))}update(){let{Input:t,Output:e}=this.ref;e.Out=w.stringToU8a(t.In)}}).output={Out:Uint8Array},g.input={In:String},g)),T.registerNode("Polkadot.js/Convert/Uint8Array To/String",((f=class extends T.Node{constructor(t){super(t),this.setInterface().title="Uint8Array to String"}init(){this.iface.input.In.on("disconnect",E.EventSlot,(()=>{this.output.Out=null}))}update(){let{Input:t,Output:e}=this.ref;e.Out=w.u8aToString(t.In)}}).output={Out:String},f.input={In:Uint8Array},f));class $ extends T.Node{constructor(t){super(t);let e=this.setInterface();this._toast=new N(this.iface),e.on("cable.disconnect",E.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}_fail(t){this.output.Bytes=null,this._toast.warn(t)}update(){let{Input:t,Output:e}=this.ref,n=this._toast;if(!t.Keypair)return this._fail("Keypair is required");if(!t.Data)return this._fail("Data is required");n.clear();let a=t.Data;return a.constructor===String&&(a=w.stringToU8a(a)),{keypair:t.Keypair,data:a}}}T.registerNode("Polkadot.js/Data/Keyring/Decrypt",((b=class extends ${constructor(t){super(t),this.iface.title="Decrypt Data"}update(){let{Input:t,Output:e}=this.ref;if(!t.Author)return this._fail("Author address is required");let n=super.update();if(!n)return;let{keypair:a,data:o}=n,s=t.Author;try{s.constructor===String&&(s=k.decodeAddress(s));var r=a.decryptMessage(o,s)}catch(t){throw this.output.Bytes=null,this._toast.error(t.message),t}if(!r)return this.output.Bytes=null,void this._toast.error("Unable to decrypt data");e.Bytes=r}}).input={Keypair:Object,Author:T.Port.Union([String,Uint8Array]),Data:T.Port.Union([String,Uint8Array])},b.output={Bytes:Uint8Array},b)),T.registerNode("Polkadot.js/Data/Keyring/Encrypt",((S=class extends ${constructor(t){super(t),this.iface.title="Encrypt Data"}update(){let{Input:t,Output:e}=this.ref;if(!t.Target)return this._fail("Target address is required");let n=super.update();if(!n)return;let{keypair:a,data:o}=n,s=t.Target;try{s.constructor===String&&(s=k.decodeAddress(s));var r=a.encryptMessage(o,s)}catch(t){throw this.output.Bytes=null,this._toast.error(t.message),t}e.Bytes=r}}).input={Keypair:Object,Target:T.Port.Union([String,Uint8Array]),Data:T.Port.Union([String,Uint8Array])},S.output={Bytes:Uint8Array},S)),T.registerNode("Polkadot.js/Events/Account/Balance",((P=class extends T.Node{constructor(t){super(t);let e=this.setInterface("BPIC/Polkadot.js/Events/Account/Balance");e.title="Account Balance Event",e.description="Listen for balance changes"}}).input={API:x.ApiPromise,Address:String},P.output={Value:Number},P)),T.registerInterface("BPIC/Polkadot.js/Events/Account/Balance",E.IFace.EventsAccountBalance=class extends T.Interface{constructor(t){super(t),this.unsubscribe=!1}imported(){let{Input:t,Output:e,IInput:n,IOutput:a}=this.ref,o=this;new N(this);n.API.on("value",E.EventSlot,(async function(){o.unsubscribe&&o.unsubscribe();let e=t.API;e&&(o.unsubscribe=await e.query.system.account(t.Address,(function(t){console.log(t)})))})).on("disconnect",E.EventSlot,(function(){o.unsubscribe&&o.unsubscribe()}))}destroy(){this.unsubscribe&&this.unsubscribe()}}),T.registerNode("Polkadot.js/Extension/Get/Signer",((_=class extends T.Node{constructor(t){super(t);let e=this.setInterface();e.title="Signer",e.description="Sign data with browser extension",this._toast=new N(this.iface),this.iface.on("cable.disconnect",E.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}async update(){let{Input:t,Output:e}=this.ref,n=this._toast;if(!t.Address)return n.warn("Address is required");!0!==L&&(n.warn("No access to browser extension"),await L),n.clear();try{var a=await polkadotExtensionDapp.web3FromAddress(t.Address)}catch(t){return n.warn(t.message)}e.Signer=new D(!1,t.Address,a.signer)}}).input={Address:String},_.output={Signer:D},_)),T.registerNode("Polkadot.js/Keyring/Create/Keypair",((A=class extends T.Node{constructor(t){super(t);let e=this.setInterface();e.title="Create Keypair",e.description="Using internal keyring",this._toast=new N(this.iface),this.iface.on("cable.disconnect",E.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}update(){let{Input:t,Output:e,IInput:n}=this.ref,a=this._toast;t.Keyring===M?this.iface.description="Using internal keyring: "+t.Keyring.type:this.iface.description="Using connected keyring: "+t.Keyring.type;let o=this._keyring;this._keyring=t.Keyring,null!=e.Keypair&&(o.removePair(e.Keypair.address),e.Keypair=null);let{Keyring:s,Seed:r,Mnemonic:i}=t;if(i&&r)return!1===this._mnemonic&&0!==n.Seed.cables.length?n.Seed.disconnectAll():void n.Mnemonic.disconnectAll();if(i){if(!O.mnemonicValidate(i))return a.warn("Invalid mnemonic, it must be 12 or 24 words");e.Keypair=s.addFromMnemonic(i),this._mnemonic=!0}else{if(null==r)return e.Keypair=null,e.Address=null,e.Signer=null,this._mnemonic=!1,a.warn("Seed or Mnemonic is required");if(32!==r.byteLength)return a.warn("Seed must be 32 bytes");e.Keypair=s.addFromSeed(r),this._mnemonic=!1}a.clear();let c=e.Keypair;e.Signer=new D(!0,c.address,c),e.Address=c.address}}).output={Keypair:Object,Address:String,Signer:D},A.input={Keyring:T.Port.Default(x.Keyring,M),Seed:T.Port.Union([String,Uint8Array]),Mnemonic:String},A)),T.registerNode("Polkadot.js/Keyring/Create/Keyring",((C=class extends T.Node{constructor(t){super(t);let e=this.setInterface();e.title="Keyring",e.description="Collection of keys",this._toast=new N(this.iface)}imported(){let{Input:t,Output:e,IInput:n}=this.ref;this.currentKeyType=t.KeyType,e.Keyring=new x.Keyring({type:t.KeyType,ss58Format:0}),n.KeyType.on("disconnect",E.EventSlot,(()=>this.update()))}update(){let{Input:t,Output:e}=this.ref,n=t.KeyType.toLowerCase(),a=this._toast;return this.currentKeyType===n?a.clear():"ed25519"!==n&&"sr25519"!==n&&"ethereum"!==n&&"ecdsa"!==n?a.warn("Invalid KeyType, it must be ed25519, sr25519, ethereum, or ecdsa"):(e.Keyring=new x.Keyring({type:n,ss58Format:0}),this.currentKeyType=n,void a.clear())}}).output={Keyring:x.Keyring},C.input={KeyType:T.Port.Default(String,"ed25519")},C)),T.registerNode("Polkadot.js/Keyring/Create/Mnemonic",((I=class extends T.Node{constructor(t){super(t);let e=this.setInterface();e.title="Create Mnemonic",e.description="Generate random mnemonic"}imported(){this.output.Text=O.mnemonicGenerate(12)}}).output={Text:String},I)),T.registerNode("Polkadot.js/Keyring/Create/Seed",((v=class extends T.Node{constructor(t){super(t);let e=this.setInterface();e.title="Random Seed",e.description="Generate random seed"}imported(){this.output.Seed=O.randomAsU8a(32)}}).output={Seed:Uint8Array},v))}("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:this,"undefined"!=typeof module?module:{exports:this});
//# sourceMappingURL=nodes-polkadotjs.mjs.map